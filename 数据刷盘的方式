一.Linux系统
传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存,大多数磁盘I/O都通过缓冲进行.当将数据写入文件时,内核通常先将该数据复制到其中一个缓冲区中,如果该缓冲区尚未写满,则并不将其排入输出队列,而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时,再将该缓冲排入输出队列,然后待其到达队首时才进行实际的I/O操作.
这种输出方式被称为延迟写（delayed write）.
延迟写减少了磁盘读写次数,但是却降低了文件内容的更新速度,使得欲写到文件中的数据在一段时间内并没有写到磁盘上.当系统发生故障时,这种延迟可能造成文件更新内容的丢失.

O_DIRECT和O_SYNC是系统调用open的flag参数,通过指定open的flag参数,以特定的文件描述符打开某一文件,这两个flag会对写盘的性能有很大的影响.
O_DIRECT: 无缓冲的输入、输出
O_SYNC: 以同步IO方式打开文件

O_DIRECT绕过缓冲区高速缓存,直接IO
Linux允许应用程序在执行磁盘IO时绕过缓冲区高速缓存,从用户空间直接将数据传递到文件或磁盘设备,称为直接IO（direct IO）或者裸IO（raw IO）
使用直接IO需要遵守的一些限制：
    1.用于传递数据的缓冲区，其内存边界必须对齐为块大小的整数倍
    2.数据传输的开始点，即文件和设备的偏移量，必须是块大小的整数倍
    3.待传递数据的长度必须是块大小的整数倍。
不遵守上述任一限制均将导致EINVAL错误

O_SYNC以同步方式写入文件
强制刷新内核缓冲区到输出文件.这是有必要的,因为为了数据安全,需要确保将数据真正写入磁盘或者磁盘的硬件高速缓存中

同步IO的定义：某一IO操作，要么已成功完成到磁盘的数据传递，要么被诊断为不成功
SUSv3定义的两种同步IO完成类型（此处用英文，因为译者也忍无可忍用了原文…）
synchronized IO data integrity completion：确保针对文件的一次更新传递了足够的信息（部分文件元数据）到磁盘，以便于之后对数据的获取。
synchronized IO file integrity completion：确保针对文件的一次更新传递了所有的信息（所有文件元数据）到磁盘，即使有些在后续对文件数据的操作并不需要。
用于控制文件IO内核缓冲的系统调用:
1.fsync
fsync()系统调用将使缓冲数据和fd相关的所有元数据都刷新到磁盘上。调用fsync会强制使文件处于Synchronized IO file integrity completion状态
2.fdatasync
fdatasync()系统调用的作用类似fsync()，只是强制文件处于synchronized IO data integrity compeletion状态
fdatasync()可能会减少磁盘操作的次数，由fsync()调用请求的两次变成一次。例如，修改了文件的数据，而文件大小不变，那么调用fdatasync调用请求只强制进行了数据更新，相比之下，fsync()调用会强制将元数据传递到磁盘上，而元数据和文件数据通常驻留在磁盘的不同区域，更新这些数据需要反复在整个磁盘上执行寻道操作
3.sync
sync()系统调用会使包含更新文件信息的所有内核缓冲区（即数据块、指针块、元数据等）刷新到磁盘上
4.使所有写入同步O_SYNC
调用open()函数时,如指定O_SYNC标志,则会使所有后续输出同步
调用open后,每个write调用会自动将文件数据和元数据刷新到磁盘上,即按照Synchronized IO file integrity completion的要求执行写操作.


sync:  只是将所有修改过的块缓冲区排入写队列,然后就返回,它并不等待实际写磁盘操作结束
fsync: 只对由文件描述符filedes指定的单一文件起作用,并且等待写磁盘操作结束,然后返回.fsync可用于数据库这样的应用程序,这种应用程序需要确保将修改过的块立即写到磁盘上
fdatasync: 类似于fsync,但它只影响文件的数据部分.而除数据外,fsync还会同步更新文件的属性
